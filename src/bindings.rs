/*
 * Copyright 2017 Sreejith Krishnan R
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/


/* automatically generated by rust-bindgen */

pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
///
pub type sk_color_t = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_colortype_t {
    UNKNOWN_SK_COLORTYPE = 0,
    RGBA_8888_SK_COLORTYPE = 1,
    BGRA_8888_SK_COLORTYPE = 2,
    ALPHA_8_SK_COLORTYPE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_alphatype_t {
    OPAQUE_SK_ALPHATYPE = 0,
    PREMUL_SK_ALPHATYPE = 1,
    UNPREMUL_SK_ALPHATYPE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_cliptype_t {
    INTERSECT_SK_CLIPTYPE = 0,
    DIFFERENCE_SK_CLIPTYPE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_pixelgeometry_t {
    UNKNOWN_SK_PIXELGEOMETRY = 0,
    RGB_H_SK_PIXELGEOMETRY = 1,
    BGR_H_SK_PIXELGEOMETRY = 2,
    RGB_V_SK_PIXELGEOMETRY = 3,
    BGR_V_SK_PIXELGEOMETRY = 4,
}
extern "C" {
    /// Return the default sk_colortype_t; this is operating-system dependent.
    pub fn sk_colortype_get_default_8888() -> sk_colortype_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sk_imageinfo_t {
    pub width: i32,
    pub height: i32,
    pub colorType: sk_colortype_t,
    pub alphaType: sk_alphatype_t,
}
#[test]
fn bindgen_test_layout_sk_imageinfo_t() {
    assert_eq!(::std::mem::size_of::<sk_imageinfo_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sk_imageinfo_t ) ));
    assert_eq! (::std::mem::align_of::<sk_imageinfo_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sk_imageinfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_imageinfo_t ) ) . width as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_imageinfo_t ) , "::"
                , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_imageinfo_t ) ) . height as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_imageinfo_t ) , "::"
                , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_imageinfo_t ) ) . colorType as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_imageinfo_t ) , "::"
                , stringify ! ( colorType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_imageinfo_t ) ) . alphaType as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_imageinfo_t ) , "::"
                , stringify ! ( alphaType ) ));
}
impl Clone for sk_imageinfo_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sk_surfaceprops_t {
    pub pixelGeometry: sk_pixelgeometry_t,
}
#[test]
fn bindgen_test_layout_sk_surfaceprops_t() {
    assert_eq!(::std::mem::size_of::<sk_surfaceprops_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( sk_surfaceprops_t ) ));
    assert_eq! (::std::mem::align_of::<sk_surfaceprops_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( sk_surfaceprops_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_surfaceprops_t ) ) . pixelGeometry as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_surfaceprops_t ) ,
                "::" , stringify ! ( pixelGeometry ) ));
}
impl Clone for sk_surfaceprops_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sk_point_t {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_sk_point_t() {
    assert_eq!(::std::mem::size_of::<sk_point_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sk_point_t ) ));
    assert_eq! (::std::mem::align_of::<sk_point_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sk_point_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_point_t ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_point_t ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_point_t ) ) . y as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_point_t ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for sk_point_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sk_irect_t {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[test]
fn bindgen_test_layout_sk_irect_t() {
    assert_eq!(::std::mem::size_of::<sk_irect_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sk_irect_t ) ));
    assert_eq! (::std::mem::align_of::<sk_irect_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sk_irect_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_irect_t ) ) . left as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_irect_t ) , "::" ,
                stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_irect_t ) ) . top as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_irect_t ) , "::" ,
                stringify ! ( top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_irect_t ) ) . right as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_irect_t ) , "::" ,
                stringify ! ( right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_irect_t ) ) . bottom as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_irect_t ) , "::" ,
                stringify ! ( bottom ) ));
}
impl Clone for sk_irect_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sk_rect_t {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[test]
fn bindgen_test_layout_sk_rect_t() {
    assert_eq!(::std::mem::size_of::<sk_rect_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sk_rect_t ) ));
    assert_eq! (::std::mem::align_of::<sk_rect_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sk_rect_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_rect_t ) ) . left as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_rect_t ) , "::" ,
                stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_rect_t ) ) . top as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_rect_t ) , "::" ,
                stringify ! ( top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_rect_t ) ) . right as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_rect_t ) , "::" ,
                stringify ! ( right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_rect_t ) ) . bottom as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_rect_t ) , "::" ,
                stringify ! ( bottom ) ));
}
impl Clone for sk_rect_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sk_matrix_t {
    pub mat: [f32; 9usize],
}
#[test]
fn bindgen_test_layout_sk_matrix_t() {
    assert_eq!(::std::mem::size_of::<sk_matrix_t>() , 36usize , concat ! (
               "Size of: " , stringify ! ( sk_matrix_t ) ));
    assert_eq! (::std::mem::align_of::<sk_matrix_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sk_matrix_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_matrix_t ) ) . mat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_matrix_t ) , "::" ,
                stringify ! ( mat ) ));
}
impl Clone for sk_matrix_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_data_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_image_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_maskfilter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_paint_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_picture_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_picture_recorder_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_shader_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_surface_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_xfermode_mode_t {
    CLEAR_SK_XFERMODE_MODE = 0,
    SRC_SK_XFERMODE_MODE = 1,
    DST_SK_XFERMODE_MODE = 2,
    SRCOVER_SK_XFERMODE_MODE = 3,
    DSTOVER_SK_XFERMODE_MODE = 4,
    SRCIN_SK_XFERMODE_MODE = 5,
    DSTIN_SK_XFERMODE_MODE = 6,
    SRCOUT_SK_XFERMODE_MODE = 7,
    DSTOUT_SK_XFERMODE_MODE = 8,
    SRCATOP_SK_XFERMODE_MODE = 9,
    DSTATOP_SK_XFERMODE_MODE = 10,
    XOR_SK_XFERMODE_MODE = 11,
    PLUS_SK_XFERMODE_MODE = 12,
    MODULATE_SK_XFERMODE_MODE = 13,
    SCREEN_SK_XFERMODE_MODE = 14,
    OVERLAY_SK_XFERMODE_MODE = 15,
    DARKEN_SK_XFERMODE_MODE = 16,
    LIGHTEN_SK_XFERMODE_MODE = 17,
    COLORDODGE_SK_XFERMODE_MODE = 18,
    COLORBURN_SK_XFERMODE_MODE = 19,
    HARDLIGHT_SK_XFERMODE_MODE = 20,
    SOFTLIGHT_SK_XFERMODE_MODE = 21,
    DIFFERENCE_SK_XFERMODE_MODE = 22,
    EXCLUSION_SK_XFERMODE_MODE = 23,
    MULTIPLY_SK_XFERMODE_MODE = 24,
    HUE_SK_XFERMODE_MODE = 25,
    SATURATION_SK_XFERMODE_MODE = 26,
    COLOR_SK_XFERMODE_MODE = 27,
    LUMINOSITY_SK_XFERMODE_MODE = 28,
}
extern "C" {
    /// Save the current matrix and clip on the canvas.  When the
/// balancing call to sk_canvas_restore() is made, the previous matrix
/// and clip are restored.
    pub fn sk_canvas_save(arg1: *mut sk_canvas_t);
}
extern "C" {
    /// This behaves the same as sk_canvas_save(), but in addition it
/// allocates an offscreen surface. All drawing calls are directed
/// there, and only when the balancing call to sk_canvas_restore() is
/// made is that offscreen transfered to the canvas (or the previous
/// layer).
///
/// @param sk_rect_t* (may be null) This rect, if non-null, is used as
/// a hint to limit the size of the offscreen, and
/// thus drawing may be clipped to it, though that
/// clipping is not guaranteed to happen. If exact
/// clipping is desired, use sk_canvas_clip_rect().
/// @param sk_paint_t* (may be null) The paint is copied, and is applied
/// to the offscreen when sk_canvas_restore() is
/// called.
    pub fn sk_canvas_save_layer(arg1: *mut sk_canvas_t,
                                arg2: *const sk_rect_t,
                                arg3: *const sk_paint_t);
}
extern "C" {
    /// This call balances a previous call to sk_canvas_save() or
/// sk_canvas_save_layer(), and is used to remove all modifications to
/// the matrix and clip state since the last save call.  It is an
/// error to call sk_canvas_restore() more times than save and
/// save_layer were called.
    pub fn sk_canvas_restore(arg1: *mut sk_canvas_t);
}
extern "C" {
    /// Preconcat the current coordinate transformation matrix with the
/// specified translation.
    pub fn sk_canvas_translate(arg1: *mut sk_canvas_t, dx: f32, dy: f32);
}
extern "C" {
    /// Preconcat the current coordinate transformation matrix with the
/// specified scale.
    pub fn sk_canvas_scale(arg1: *mut sk_canvas_t, sx: f32, sy: f32);
}
extern "C" {
    /// Preconcat the current coordinate transformation matrix with the
/// specified rotation in degrees.
    pub fn sk_canvas_rotate_degrees(arg1: *mut sk_canvas_t, degrees: f32);
}
extern "C" {
    /// Preconcat the current coordinate transformation matrix with the
/// specified rotation in radians.
    pub fn sk_canvas_rotate_radians(arg1: *mut sk_canvas_t, radians: f32);
}
extern "C" {
    /// Preconcat the current coordinate transformation matrix with the
/// specified skew.
    pub fn sk_canvas_skew(arg1: *mut sk_canvas_t, sx: f32, sy: f32);
}
extern "C" {
    /// Preconcat the current coordinate transformation matrix with the
/// specified matrix.
    pub fn sk_canvas_concat(arg1: *mut sk_canvas_t, arg2: *const sk_matrix_t);
}
extern "C" {
    /// Modify the current clip with the specified rectangle.  The new
/// current clip will be the intersection of the old clip and the
/// rectange.
    pub fn sk_canvas_clip_rect(arg1: *mut sk_canvas_t,
                               arg2: *const sk_rect_t);
}
extern "C" {
    /// Modify the current clip with the specified path.  The new
/// current clip will be the intersection of the old clip and the
/// path.
    pub fn sk_canvas_clip_path(arg1: *mut sk_canvas_t,
                               arg2: *const sk_path_t);
}
extern "C" {
    /// Fill the entire canvas (restricted to the current clip) with the
/// specified paint.
    pub fn sk_canvas_draw_paint(arg1: *mut sk_canvas_t,
                                arg2: *const sk_paint_t);
}
extern "C" {
    /// Draw the specified rectangle using the specified paint. The
/// rectangle will be filled or stroked based on the style in the
/// paint.
    pub fn sk_canvas_draw_rect(arg1: *mut sk_canvas_t, arg2: *const sk_rect_t,
                               arg3: *const sk_paint_t);
}
extern "C" {
    /// Draw the circle centered at (cx, cy) with radius rad using the specified paint.
/// The circle will be filled or framed based on the style in the paint
    pub fn sk_canvas_draw_circle(arg1: *mut sk_canvas_t, cx: f32, cy: f32,
                                 rad: f32, arg2: *const sk_paint_t);
}
extern "C" {
    /// Draw the specified oval using the specified paint. The oval will be
/// filled or framed based on the style in the paint
    pub fn sk_canvas_draw_oval(arg1: *mut sk_canvas_t, arg2: *const sk_rect_t,
                               arg3: *const sk_paint_t);
}
extern "C" {
    /// Draw the specified path using the specified paint. The path will be
/// filled or framed based on the style in the paint
    pub fn sk_canvas_draw_path(arg1: *mut sk_canvas_t, arg2: *const sk_path_t,
                               arg3: *const sk_paint_t);
}
extern "C" {
    /// Draw the specified image, with its top/left corner at (x,y), using
/// the specified paint, transformed by the current matrix.
///
/// @param sk_paint_t* (may be NULL) the paint used to draw the image.
    pub fn sk_canvas_draw_image(arg1: *mut sk_canvas_t,
                                arg2: *const sk_image_t, x: f32, y: f32,
                                arg3: *const sk_paint_t);
}
extern "C" {
    /// Draw the specified image, scaling and translating so that it fills
/// the specified dst rect. If the src rect is non-null, only that
/// subset of the image is transformed and drawn.
///
/// @param sk_paint_t* (may be NULL) The paint used to draw the image.
    pub fn sk_canvas_draw_image_rect(arg1: *mut sk_canvas_t,
                                     arg2: *const sk_image_t,
                                     src: *const sk_rect_t,
                                     dst: *const sk_rect_t,
                                     arg3: *const sk_paint_t);
}
extern "C" {
    /// Draw the picture into this canvas (replay the pciture's drawing commands).
///
/// @param sk_matrix_t* If non-null, apply that matrix to the CTM when
/// drawing this picture. This is logically
/// equivalent to: save, concat, draw_picture,
/// restore.
///
/// @param sk_paint_t* If non-null, draw the picture into a temporary
/// buffer, and then apply the paint's alpha,
/// colorfilter, imagefilter, and xfermode to that
/// buffer as it is drawn to the canvas.  This is
/// logically equivalent to save_layer(paint),
/// draw_picture, restore.
    pub fn sk_canvas_draw_picture(arg1: *mut sk_canvas_t,
                                  arg2: *const sk_picture_t,
                                  arg3: *const sk_matrix_t,
                                  arg4: *const sk_paint_t);
}
extern "C" {
    /// Returns a new empty sk_data_t.  This call must be balanced with a call to
/// sk_data_unref().
    pub fn sk_data_new_empty() -> *mut sk_data_t;
}
extern "C" {
    /// Returns a new sk_data_t by copying the specified source data.
/// This call must be balanced with a call to sk_data_unref().
    pub fn sk_data_new_with_copy(src: *const ::std::os::raw::c_void,
                                 length: usize) -> *mut sk_data_t;
}
extern "C" {
    /// Pass ownership of the given memory to a new sk_data_t, which will
/// call free() when the refernce count of the data goes to zero.  For
/// example:
/// size_t length = 1024;
/// void* buffer = malloc(length);
/// memset(buffer, 'X', length);
/// sk_data_t* data = sk_data_new_from_malloc(buffer, length);
/// This call must be balanced with a call to sk_data_unref().
    pub fn sk_data_new_from_malloc(memory: *const ::std::os::raw::c_void,
                                   length: usize) -> *mut sk_data_t;
}
extern "C" {
    /// Returns a new sk_data_t using a subset of the data in the
/// specified source sk_data_t.  This call must be balanced with a
/// call to sk_data_unref().
    pub fn sk_data_new_subset(src: *const sk_data_t, offset: usize,
                              length: usize) -> *mut sk_data_t;
}
extern "C" {
    /// Increment the reference count on the given sk_data_t. Must be
/// balanced by a call to sk_data_unref().
    pub fn sk_data_ref(arg1: *const sk_data_t);
}
extern "C" {
    /// Decrement the reference count. If the reference count is 1 before
/// the decrement, then release both the memory holding the sk_data_t
/// and the memory it is managing.  New sk_data_t are created with a
/// reference count of 1.
    pub fn sk_data_unref(arg1: *const sk_data_t);
}
extern "C" {
    /// Returns the number of bytes stored.
    pub fn sk_data_get_size(arg1: *const sk_data_t) -> usize;
}
extern "C" {
    /// Returns the pointer to the data.
    pub fn sk_data_get_data(arg1: *const sk_data_t)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /// Return a new image that has made a copy of the provided pixels, or NULL on failure.
/// Balance with a call to sk_image_unref().
    pub fn sk_image_new_raster_copy(arg1: *const sk_imageinfo_t,
                                    pixels: *const ::std::os::raw::c_void,
                                    rowBytes: usize) -> *mut sk_image_t;
}
extern "C" {
    /// If the specified data can be interpreted as a compressed image (e.g. PNG or JPEG) then this
/// returns an image. If the encoded data is not supported, returns NULL.
///
/// On success, the encoded data may be processed immediately, or it may be ref()'d for later
/// use.
    pub fn sk_image_new_from_encoded(encoded: *const sk_data_t,
                                     subset: *const sk_irect_t)
     -> *mut sk_image_t;
}
extern "C" {
    /// Encode the image's pixels and return the result as a new PNG in a
/// sk_data_t, which the caller must manage: call sk_data_unref() when
/// they are done.
///
/// If the image type cannot be encoded, this will return NULL.
    pub fn sk_image_encode(arg1: *const sk_image_t) -> *mut sk_data_t;
}
extern "C" {
    /// Increment the reference count on the given sk_image_t. Must be
/// balanced by a call to sk_image_unref().
    pub fn sk_image_ref(arg1: *const sk_image_t);
}
extern "C" {
    /// Decrement the reference count. If the reference count is 1 before
/// the decrement, then release both the memory holding the sk_image_t
/// and the memory it is managing.  New sk_image_t are created with a
/// reference count of 1.
    pub fn sk_image_unref(arg1: *const sk_image_t);
}
extern "C" {
    /// Return the width of the sk_image_t/
    pub fn sk_image_get_width(arg1: *const sk_image_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the height of the sk_image_t/
    pub fn sk_image_get_height(arg1: *const sk_image_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Returns a non-zero value unique among all images.
    pub fn sk_image_get_unique_id(arg1: *const sk_image_t) -> u32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_blurstyle_t {
    NORMAL_SK_BLUR_STYLE = 0,
    SOLID_SK_BLUR_STYLE = 1,
    OUTER_SK_BLUR_STYLE = 2,
    INNER_SK_BLUR_STYLE = 3,
}
extern "C" {
    /// Increment the reference count on the given sk_maskfilter_t. Must be
/// balanced by a call to sk_maskfilter_unref().
    pub fn sk_maskfilter_ref(arg1: *mut sk_maskfilter_t);
}
extern "C" {
    /// Decrement the reference count. If the reference count is 1 before
/// the decrement, then release both the memory holding the
/// sk_maskfilter_t and any other associated resources.  New
/// sk_maskfilter_t are created with a reference count of 1.
    pub fn sk_maskfilter_unref(arg1: *mut sk_maskfilter_t);
}
extern "C" {
    /// Create a blur maskfilter.
/// @param sk_blurstyle_t The SkBlurStyle to use
/// @param sigma Standard deviation of the Gaussian blur to apply. Must be > 0.
    pub fn sk_maskfilter_new_blur(arg1: sk_blurstyle_t, sigma: f32)
     -> *mut sk_maskfilter_t;
}
extern "C" {
    /// Set the matrix to identity
    pub fn sk_matrix_set_identity(arg1: *mut sk_matrix_t);
}
extern "C" {
    /// Set the matrix to translate by (tx, ty).
    pub fn sk_matrix_set_translate(arg1: *mut sk_matrix_t, tx: f32, ty: f32);
}
extern "C" {
    /// Preconcats the matrix with the specified translation.
/// M' = M * T(dx, dy)
    pub fn sk_matrix_pre_translate(arg1: *mut sk_matrix_t, tx: f32, ty: f32);
}
extern "C" {
    /// Postconcats the matrix with the specified translation.
/// M' = T(dx, dy) * M
    pub fn sk_matrix_post_translate(arg1: *mut sk_matrix_t, tx: f32, ty: f32);
}
extern "C" {
    /// Set the matrix to scale by sx and sy.
    pub fn sk_matrix_set_scale(arg1: *mut sk_matrix_t, sx: f32, sy: f32);
}
extern "C" {
    /// Preconcats the matrix with the specified scale.
/// M' = M * S(sx, sy)
    pub fn sk_matrix_pre_scale(arg1: *mut sk_matrix_t, sx: f32, sy: f32);
}
extern "C" {
    /// Postconcats the matrix with the specified scale.
/// M' = S(sx, sy) * M
    pub fn sk_matrix_post_scale(arg1: *mut sk_matrix_t, sx: f32, sy: f32);
}
extern "C" {
    /// Create a new paint with default settings:
/// antialias : false
/// stroke : false
/// stroke width : 0.0f (hairline)
/// stroke miter : 4.0f
/// stroke cap : BUTT_SK_STROKE_CAP
/// stroke join : MITER_SK_STROKE_JOIN
/// color : opaque black
/// shader : NULL
/// maskfilter : NULL
/// xfermode_mode : SRCOVER_SK_XFERMODE_MODE
    pub fn sk_paint_new() -> *mut sk_paint_t;
}
extern "C" {
    /// Release the memory storing the sk_paint_t and unref() all
/// associated objects.
    pub fn sk_paint_delete(arg1: *mut sk_paint_t);
}
extern "C" {
    /// Return true iff the paint has antialiasing enabled.
    pub fn sk_paint_is_antialias(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    /// Set to true to enable antialiasing, false to disable it on this
/// sk_paint_t.
    pub fn sk_paint_set_antialias(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    /// Return the paint's curent drawing color.
    pub fn sk_paint_get_color(arg1: *const sk_paint_t) -> sk_color_t;
}
extern "C" {
    /// Set the paint's curent drawing color.
    pub fn sk_paint_set_color(arg1: *mut sk_paint_t, arg2: sk_color_t);
}
extern "C" {
    /// Return true iff stroking is enabled rather than filling on this
/// sk_paint_t.
    pub fn sk_paint_is_stroke(arg1: *const sk_paint_t) -> bool;
}
extern "C" {
    /// Set to true to enable stroking rather than filling with this
/// sk_paint_t.
    pub fn sk_paint_set_stroke(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    /// Return the width for stroking.  A value of 0 strokes in hairline mode.
    pub fn sk_paint_get_stroke_width(arg1: *const sk_paint_t) -> f32;
}
extern "C" {
    /// Set the width for stroking.  A value of 0 strokes in hairline mode
/// (always draw 1-pixel wide, regardless of the matrix).
    pub fn sk_paint_set_stroke_width(arg1: *mut sk_paint_t, width: f32);
}
extern "C" {
    /// Return the paint's stroke miter value. This is used to control the
/// behavior of miter joins when the joins angle is sharp.
    pub fn sk_paint_get_stroke_miter(arg1: *const sk_paint_t) -> f32;
}
extern "C" {
    /// Set the paint's stroke miter value. This is used to control the
/// behavior of miter joins when the joins angle is sharp. This value
/// must be >= 0.
    pub fn sk_paint_set_stroke_miter(arg1: *mut sk_paint_t, miter: f32);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_stroke_cap_t {
    BUTT_SK_STROKE_CAP = 0,
    ROUND_SK_STROKE_CAP = 1,
    SQUARE_SK_STROKE_CAP = 2,
}
extern "C" {
    /// Return the paint's stroke cap type, controlling how the start and
/// end of stroked lines and paths are treated.
    pub fn sk_paint_get_stroke_cap(arg1: *const sk_paint_t)
     -> sk_stroke_cap_t;
}
extern "C" {
    /// Set the paint's stroke cap type, controlling how the start and
/// end of stroked lines and paths are treated.
    pub fn sk_paint_set_stroke_cap(arg1: *mut sk_paint_t,
                                   arg2: sk_stroke_cap_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_stroke_join_t {
    MITER_SK_STROKE_JOIN = 0,
    ROUND_SK_STROKE_JOIN = 1,
    BEVEL_SK_STROKE_JOIN = 2,
}
extern "C" {
    /// Return the paint's stroke join type, specifies the treatment that
/// is applied to corners in paths and rectangles
    pub fn sk_paint_get_stroke_join(arg1: *const sk_paint_t)
     -> sk_stroke_join_t;
}
extern "C" {
    /// Set the paint's stroke join type, specifies the treatment that
/// is applied to corners in paths and rectangles
    pub fn sk_paint_set_stroke_join(arg1: *mut sk_paint_t,
                                    arg2: sk_stroke_join_t);
}
extern "C" {
    /// Set the paint's shader to the specified parameter. This will automatically call unref() on
/// any previous value, and call ref() on the new value.
    pub fn sk_paint_set_shader(arg1: *mut sk_paint_t, arg2: *mut sk_shader_t);
}
extern "C" {
    /// Set the paint's maskfilter to the specified parameter. This will automatically call unref() on
/// any previous value, and call ref() on the new value.
    pub fn sk_paint_set_maskfilter(arg1: *mut sk_paint_t,
                                   arg2: *mut sk_maskfilter_t);
}
extern "C" {
    /// Set the paint's xfermode to the specified parameter.
    pub fn sk_paint_set_xfermode_mode(arg1: *mut sk_paint_t,
                                      arg2: sk_xfermode_mode_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_path_direction_t {
    CW_SK_PATH_DIRECTION = 0,
    CCW_SK_PATH_DIRECTION = 1,
}
extern "C" {
    /// Create a new, empty path.
    pub fn sk_path_new() -> *mut sk_path_t;
}
extern "C" {
    /// Release the memory used by a sk_path_t.
    pub fn sk_path_delete(arg1: *mut sk_path_t);
}
extern "C" {
    /// Set the beginning of the next contour to the point (x,y).
    pub fn sk_path_move_to(arg1: *mut sk_path_t, x: f32, y: f32);
}
extern "C" {
    /// Add a line from the last point to the specified point (x,y). If no
/// sk_path_move_to() call has been made for this contour, the first
/// point is automatically set to (0,0).
    pub fn sk_path_line_to(arg1: *mut sk_path_t, x: f32, y: f32);
}
extern "C" {
    /// Add a quadratic bezier from the last point, approaching control
/// point (x0,y0), and ending at (x1,y1). If no sk_path_move_to() call
/// has been made for this contour, the first point is automatically
/// set to (0,0).
    pub fn sk_path_quad_to(arg1: *mut sk_path_t, x0: f32, y0: f32, x1: f32,
                           y1: f32);
}
extern "C" {
    /// Add a conic curve from the last point, approaching control point
/// (x0,y01), and ending at (x1,y1) with weight w.  If no
/// sk_path_move_to() call has been made for this contour, the first
/// point is automatically set to (0,0).
    pub fn sk_path_conic_to(arg1: *mut sk_path_t, x0: f32, y0: f32, x1: f32,
                            y1: f32, w: f32);
}
extern "C" {
    /// Add a cubic bezier from the last point, approaching control points
/// (x0,y0) and (x1,y1), and ending at (x2,y2). If no
/// sk_path_move_to() call has been made for this contour, the first
/// point is automatically set to (0,0).
    pub fn sk_path_cubic_to(arg1: *mut sk_path_t, x0: f32, y0: f32, x1: f32,
                            y1: f32, x2: f32, y2: f32);
}
extern "C" {
    /// Close the current contour. If the current point is not equal to the
/// first point of the contour, a line segment is automatically added.
    pub fn sk_path_close(arg1: *mut sk_path_t);
}
extern "C" {
    /// Add a closed rectangle contour to the path.
    pub fn sk_path_add_rect(arg1: *mut sk_path_t, arg2: *const sk_rect_t,
                            arg3: sk_path_direction_t);
}
extern "C" {
    /// Add a closed oval contour to the path
    pub fn sk_path_add_oval(arg1: *mut sk_path_t, arg2: *const sk_rect_t,
                            arg3: sk_path_direction_t);
}
extern "C" {
    /// If the path is empty, return false and set the rect parameter to [0, 0, 0, 0].
/// else return true and set the rect parameter to the bounds of the control-points
/// of the path.
    pub fn sk_path_get_bounds(arg1: *const sk_path_t, arg2: *mut sk_rect_t)
     -> bool;
}
extern "C" {
    /// Create a new sk_picture_recorder_t.  Its resources should be
/// released with a call to sk_picture_recorder_delete().
    pub fn sk_picture_recorder_new() -> *mut sk_picture_recorder_t;
}
extern "C" {
    /// Release the memory and other resources used by this
/// sk_picture_recorder_t.
    pub fn sk_picture_recorder_delete(arg1: *mut sk_picture_recorder_t);
}
extern "C" {
    /// Returns the canvas that records the drawing commands
///
/// @param sk_rect_t* the cull rect used when recording this
/// picture. Any drawing the falls outside of this
/// rect is undefined, and may be drawn or it may not.
    pub fn sk_picture_recorder_begin_recording(arg1:
                                                   *mut sk_picture_recorder_t,
                                               arg2: *const sk_rect_t)
     -> *mut sk_canvas_t;
}
extern "C" {
    /// Signal that the caller is done recording. This invalidates the
/// canvas returned by begin_recording. Ownership of the sk_picture_t
/// is passed to the caller, who must call sk_picture_unref() when
/// they are done using it.  The returned picture is immutable.
    pub fn sk_picture_recorder_end_recording(arg1: *mut sk_picture_recorder_t)
     -> *mut sk_picture_t;
}
extern "C" {
    /// Increment the reference count on the given sk_picture_t. Must be
/// balanced by a call to sk_picture_unref().
    pub fn sk_picture_ref(arg1: *mut sk_picture_t);
}
extern "C" {
    /// Decrement the reference count. If the reference count is 1 before
/// the decrement, then release both the memory holding the
/// sk_picture_t and any resouces it may be managing.  New
/// sk_picture_t are created with a reference count of 1.
    pub fn sk_picture_unref(arg1: *mut sk_picture_t);
}
extern "C" {
    /// Returns a non-zero value unique among all pictures.
    pub fn sk_picture_get_unique_id(arg1: *mut sk_picture_t) -> u32;
}
extern "C" {
    /// Return the cull rect specified when this picture was recorded.
    pub fn sk_picture_get_bounds(arg1: *mut sk_picture_t) -> sk_rect_t;
}
extern "C" {
    pub fn sk_shader_ref(arg1: *mut sk_shader_t);
}
extern "C" {
    pub fn sk_shader_unref(arg1: *mut sk_shader_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sk_shader_tilemode_t {
    CLAMP_SK_SHADER_TILEMODE = 0,
    REPEAT_SK_SHADER_TILEMODE = 1,
    MIRROR_SK_SHADER_TILEMODE = 2,
}
extern "C" {
    /// Returns a shader that generates a linear gradient between the two
/// specified points.
///
/// @param points The start and end points for the gradient.
/// @param colors The array[count] of colors, to be distributed between
/// the two points
/// @param colorPos May be NULL. array[count] of SkScalars, or NULL, of
/// the relative position of each corresponding color
/// in the colors array. If this is NULL, the the
/// colors are distributed evenly between the start
/// and end point.  If this is not null, the values
/// must begin with 0, end with 1.0, and intermediate
/// values must be strictly increasing.
/// @param colorCount Must be >=2. The number of colors (and pos if not
/// NULL) entries.
/// @param mode The tiling mode
    pub fn sk_shader_new_linear_gradient(points: *const sk_point_t,
                                         colors: *const sk_color_t,
                                         colorPos: *const f32,
                                         colorCount: ::std::os::raw::c_int,
                                         tileMode: sk_shader_tilemode_t,
                                         localMatrix: *const sk_matrix_t)
     -> *mut sk_shader_t;
}
extern "C" {
    /// Returns a shader that generates a radial gradient given the center
/// and radius.
///
/// @param center The center of the circle for this gradient
/// @param radius Must be positive. The radius of the circle for this
/// gradient
/// @param colors The array[count] of colors, to be distributed
/// between the center and edge of the circle
/// @param colorPos May be NULL. The array[count] of the relative
/// position of each corresponding color in the colors
/// array. If this is NULL, the the colors are
/// distributed evenly between the center and edge of
/// the circle.  If this is not null, the values must
/// begin with 0, end with 1.0, and intermediate
/// values must be strictly increasing.
/// @param count Must be >= 2. The number of colors (and pos if not
/// NULL) entries
/// @param tileMode The tiling mode
/// @param localMatrix May be NULL
    pub fn sk_shader_new_radial_gradient(center: *const sk_point_t,
                                         radius: f32,
                                         colors: *const sk_color_t,
                                         colorPos: *const f32,
                                         colorCount: ::std::os::raw::c_int,
                                         tileMode: sk_shader_tilemode_t,
                                         localMatrix: *const sk_matrix_t)
     -> *mut sk_shader_t;
}
extern "C" {
    /// Returns a shader that generates a sweep gradient given a center.
///
/// @param center The coordinates of the center of the sweep
/// @param colors The array[count] of colors, to be distributed around
/// the center.
/// @param colorPos May be NULL. The array[count] of the relative
/// position of each corresponding color in the colors
/// array. If this is NULL, the the colors are
/// distributed evenly between the center and edge of
/// the circle.  If this is not null, the values must
/// begin with 0, end with 1.0, and intermediate
/// values must be strictly increasing.
/// @param colorCount Must be >= 2. The number of colors (and pos if
/// not NULL) entries
/// @param localMatrix May be NULL
    pub fn sk_shader_new_sweep_gradient(center: *const sk_point_t,
                                        colors: *const sk_color_t,
                                        colorPos: *const f32,
                                        colorCount: ::std::os::raw::c_int,
                                        localMatrix: *const sk_matrix_t)
     -> *mut sk_shader_t;
}
extern "C" {
    /// Returns a shader that generates a conical gradient given two circles, or
/// returns NULL if the inputs are invalid. The gradient interprets the
/// two circles according to the following HTML spec.
/// http://dev.w3.org/html5/2dcontext/#dom-context-2d-createradialgradient
///
/// Returns a shader that generates a sweep gradient given a center.
///
/// @param start, startRadius Defines the first circle.
/// @param end, endRadius Defines the first circle.
/// @param colors The array[count] of colors, to be distributed between
/// the two circles.
/// @param colorPos May be NULL. The array[count] of the relative
/// position of each corresponding color in the colors
/// array. If this is NULL, the the colors are
/// distributed evenly between the two circles.  If
/// this is not null, the values must begin with 0,
/// end with 1.0, and intermediate values must be
/// strictly increasing.
/// @param colorCount Must be >= 2. The number of colors (and pos if
/// not NULL) entries
/// @param tileMode The tiling mode
/// @param localMatrix May be NULL
    pub fn sk_shader_new_two_point_conical_gradient(start: *const sk_point_t,
                                                    startRadius: f32,
                                                    end: *const sk_point_t,
                                                    endRadius: f32,
                                                    colors: *const sk_color_t,
                                                    colorPos: *const f32,
                                                    colorCount:
                                                        ::std::os::raw::c_int,
                                                    tileMode:
                                                        sk_shader_tilemode_t,
                                                    localMatrix:
                                                        *const sk_matrix_t)
     -> *mut sk_shader_t;
}
extern "C" {
    /// Return a new surface, with the memory for the pixels automatically
/// allocated.  If the requested surface cannot be created, or the
/// request is not a supported configuration, NULL will be returned.
///
/// @param sk_imageinfo_t* Specify the width, height, color type, and
/// alpha type for the surface.
///
/// @param sk_surfaceprops_t* If not NULL, specify additional non-default
/// properties of the surface.
    pub fn sk_surface_new_raster(arg1: *const sk_imageinfo_t,
                                 arg2: *const sk_surfaceprops_t)
     -> *mut sk_surface_t;
}
extern "C" {
    /// Create a new surface which will draw into the specified pixels
/// with the specified rowbytes.  If the requested surface cannot be
/// created, or the request is not a supported configuration, NULL
/// will be returned.
///
/// @param sk_imageinfo_t* Specify the width, height, color type, and
/// alpha type for the surface.
/// @param void* pixels Specify the location in memory where the
/// destination pixels are.  This memory must
/// outlast this surface.
/// @param size_t rowBytes Specify the difference, in bytes, between
/// each adjacent row.  Should be at least
/// (width * sizeof(one pixel)).
/// @param sk_surfaceprops_t* If not NULL, specify additional non-default
/// properties of the surface.
    pub fn sk_surface_new_raster_direct(arg1: *const sk_imageinfo_t,
                                        pixels: *mut ::std::os::raw::c_void,
                                        rowBytes: usize,
                                        props: *const sk_surfaceprops_t)
     -> *mut sk_surface_t;
}
extern "C" {
    /// Decrement the reference count. If the reference count is 1 before
/// the decrement, then release both the memory holding the
/// sk_surface_t and any pixel memory it may be managing.  New
/// sk_surface_t are created with a reference count of 1.
    pub fn sk_surface_unref(arg1: *mut sk_surface_t);
}
extern "C" {
    /// Return the canvas associated with this surface. Note: the canvas is owned by the surface,
/// so the returned object is only valid while the owning surface is valid.
    pub fn sk_surface_get_canvas(arg1: *mut sk_surface_t) -> *mut sk_canvas_t;
}
extern "C" {
    /// Call sk_image_unref() when the returned image is no longer used.
    pub fn sk_surface_new_image_snapshot(arg1: *mut sk_surface_t)
     -> *mut sk_image_t;
}
extern "C" {
    /// Draw the text, with origin at (x,y), using the specified paint.
/// The origin is interpreted based on the Align setting in the paint.
/// @param ccanvas
/// @param text The text to be drawn
/// @param byteLength   The number of bytes to read from the text parameter
/// @param x        The x-coordinate of the origin of the text being drawn
/// @param y        The y-coordinate of the origin of the text being drawn
/// @param paint    The paint used for the text (e.g. color, size, style)
    pub fn sk_canvas_draw_text(ccanvas: *mut sk_canvas_t,
                               text: *const ::std::os::raw::c_void,
                               length: usize, x: f32, y: f32,
                               cpaint: *const sk_paint_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_typeface_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sk_font_metrics_t {
    /// !< Bit field to identify which values are unknown
    pub fFlags: ::std::os::raw::c_uint,
    /// !< The greatest distance above the baseline for any glyph (will be <= 0)
    pub fTop: f32,
    /// !< The recommended distance above the baseline (will be <= 0)
    pub fAscent: f32,
    /// !< The recommended distance below the baseline (will be >= 0)
    pub fDescent: f32,
    /// !< The greatest distance below the baseline for any glyph (will be >= 0)
    pub fBottom: f32,
    /// !< The recommended distance to add between lines of text (will be >= 0)
    pub fLeading: f32,
    /// !< the average character width (>= 0)
    pub fAvgCharWidth: f32,
    /// !< the max character width (>= 0)
    pub fMaxCharWidth: f32,
    /// !< The minimum bounding box x value for all glyphs
    pub fXMin: f32,
    /// !< The maximum bounding box x value for all glyphs
    pub fXMax: f32,
    /// !< The height of an 'x' in px, or 0 if no 'x' in face
    pub fXHeight: f32,
    /// !< The cap height (> 0), or 0 if cannot be determined.
    pub fCapHeight: f32,
    /// !< underline thickness, or 0 if cannot be determined
    pub fUnderlineThickness: f32,
    /// !< underline position, or 0 if cannot be determined
    pub fUnderlinePosition: f32,
}
#[test]
fn bindgen_test_layout_sk_font_metrics_t() {
    assert_eq!(::std::mem::size_of::<sk_font_metrics_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( sk_font_metrics_t ) ));
    assert_eq! (::std::mem::align_of::<sk_font_metrics_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( sk_font_metrics_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fFlags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fTop as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fTop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fAscent as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fAscent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fDescent as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fDescent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fBottom as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fBottom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fLeading as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fLeading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fAvgCharWidth as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fAvgCharWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fMaxCharWidth as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fMaxCharWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fXMin as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fXMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fXMax as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fXMax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fXHeight as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fXHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) . fCapHeight as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fCapHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) .
                fUnderlineThickness as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fUnderlineThickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sk_font_metrics_t ) ) .
                fUnderlinePosition as * const _ as usize } , 52usize , concat
                ! (
                "Alignment of field: " , stringify ! ( sk_font_metrics_t ) ,
                "::" , stringify ! ( fUnderlinePosition ) ));
}
impl Clone for sk_font_metrics_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Helper for setFlags(), setting or clearing the kDither_Flag bit
/// @param dither   true to enable dithering, false to disable it
    pub fn sk_paint_set_dither(arg1: *mut sk_paint_t, arg2: bool);
}
extern "C" {
    /// Helper for getFlags(), returning true if kDither_Flag bit is set
/// @return true if the dithering bit is set in the paint's flags.
    pub fn sk_paint_is_dither(arg1: *mut sk_paint_t) -> bool;
}
extern "C" {
    /// Set the paint's text size. This value must be > 0
/// @param textSize set the paint's text size.
    pub fn sk_paint_set_text_size(arg1: *mut sk_paint_t, arg2: f32);
}
extern "C" {
    /// Return the paint's text size.
/// @return the paint's text size.
    pub fn sk_paint_get_text_size(arg1: *mut sk_paint_t) -> f32;
}
extern "C" {
    /// Set or clear the typeface object.
/// <p />
/// Pass NULL to clear any previous typeface.
/// As a convenience, the parameter passed is also returned.
/// If a previous typeface exists, its reference count is decremented.
/// If typeface is not NULL, its reference count is incremented.
/// @param typeface May be NULL. The new typeface to be installed in the
/// paint
/// @return         void
    pub fn sk_paint_set_typeface(arg1: *mut sk_paint_t,
                                 typeface: *mut sk_typeface_t);
}
extern "C" {
    /// Return the recommend spacing between lines (which will be
/// fDescent - fAscent + fLeading).
/// If metrics is not null, return in it the font metrics for the
/// typeface/pointsize/etc. currently set in the paint.
/// @param metrics      If not null, returns the font metrics for the
/// current typeface/pointsize/etc setting in this
/// paint.
/// @param scale        If not 0, return width as if the canvas were scaled
/// by this value
/// @param return the recommended spacing between lines
    pub fn sk_paint_get_font_metrics(arg1: *mut sk_paint_t,
                                     metrics: *mut sk_font_metrics_t,
                                     scale: f32) -> f32;
}
extern "C" {
    /// Return a new typeface given a file. If the file does not exist, or is
/// not a valid font file, returns nullptr.
    pub fn sk_typeface_new_from_file(path: *const ::std::os::raw::c_char,
                                     index: ::std::os::raw::c_uint)
     -> *mut sk_typeface_t;
}
extern "C" {
    /// Dereference
    pub fn sk_typeface_unref(arg1: *mut sk_typeface_t);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
